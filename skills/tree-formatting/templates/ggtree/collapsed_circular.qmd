---
title: "GENE_FAMILY circular ggtree tree"
subtitle: "Collapsed circular layout with midpoint rooting"
author: "Your Name"
date: today
status: development
format:
  html:
    toc: true
    toc-depth: 2
    number-sections: true
    code-overflow: wrap
    code-fold: false
    code-tools: true
    highlight-style: github
    theme: cosmo
    fontsize: 1rem
    linestretch: 1.5
    self-contained: true
execute:
  echo: true
  message: false
  warning: false
  cache: false
---

<!--
TEMPLATE: Collapsed Circular Tree (Overview and/or Labeled)
============================================================
Large trees (100+ tips) rendered in circular layout with:
  - Pure-clade collapsing by taxonomic group (colored triangles)
  - Branch coloring by taxonomy
  - Optional selective tip labeling with manual angle computation
  - Model species gene names on collapsed triangle labels
  - No branch capping (branch lengths are never manipulated)

Produces:
  - Circular overview (no labels) — good for showing overall structure
  - Circular labeled (selective labels) — manually positioned labels

CRITICAL CIRCULAR GOTCHA: Labels must be positioned BEFORE collapse() is
called. The template handles this by computing angles from y-position
(y / max_y * 360), flipping text on the left half of the circle, and using
geom_text() with explicit angle/hjust values instead of geom_tiplab2().

USAGE: Copy this template into your project's scripts/ directory,
       then adapt the sections marked PROJECT-SPECIFIC.
-->

## Setup

```{r setup}
suppressPackageStartupMessages({
  library(ape)
  library(ggtree)
  library(treeio)
  library(ggplot2)
  library(tidytree)
  library(phytools)
  library(here)
})

git_hash <- system("git rev-parse --short HEAD", intern = TRUE)
cat("Rendered from commit:", git_hash, "\n")

# PROJECT-SPECIFIC: Output directory
out_dir <- here("outs", "phylogenetics", "XX_tree_name")
dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)
```

## Inputs

```{r inputs}
# PROJECT-SPECIFIC: Tree file and optional metadata
tree_file <- here("data", "phylogenetics", "GENE", "ALIGNMENT.treefile")

tree <- read.tree(tree_file)
cat("Tips:", Ntip(tree), "\n")
```

## Taxonomy and label parsing

```{r taxonomy}
# =============================================================================
# PROJECT-SPECIFIC: Tip label parsing
# =============================================================================
# These functions MUST be adapted to match the actual label formats in each tree.
# Inspect tip labels first: head(tree$tip.label, 20)

parse_species_id <- function(label) {
  if (grepl("^(sp|tr)\\|", label)) {
    parts <- strsplit(label, "\\|")[[1]]
    if (length(parts) >= 3) return(sub(".*_", "", parts[3]))
  }
  if (grepl("\\|", label)) return(strsplit(label, "\\|")[[1]][1])
  return(label)
}

parse_accession <- function(label) {
  if (grepl("^(sp|tr)\\|", label)) return(strsplit(label, "\\|")[[1]][2])
  if (grepl("\\|", label)) {
    after_pipe <- strsplit(label, "\\|")[[1]][2]
    return(sub("^[0-9]+\\.", "", after_pipe))
  }
  return(NA_character_)
}

parse_gene_name_sp <- function(label) {
  if (grepl("^sp\\|", label)) {
    parts <- strsplit(label, "\\|")[[1]]
    if (length(parts) >= 3) return(sub("_[^_]+$", "", parts[3]))
  }
  return(NA_character_)
}

gene_map_file <- file.path(out_dir, "accession_gene_map.tsv")
if (file.exists(gene_map_file)) {
  gene_map <- read.delim(gene_map_file, stringsAsFactors = FALSE)
  acc_to_gene <- setNames(gene_map$gene_name, gene_map$accession)
} else {
  acc_to_gene <- character(0)
}

resolve_gene_name <- function(label, species_id) {
  sp_gene <- parse_gene_name_sp(label)
  if (!is.na(sp_gene)) return(sp_gene)
  acc <- parse_accession(label)
  if (!is.na(acc) && acc %in% names(acc_to_gene)) {
    gene <- acc_to_gene[acc]
    if (!is.na(gene) && nchar(gene) > 0) return(gene)
  }
  if (!is.na(acc)) return(acc)
  return(NA_character_)
}

# =============================================================================
# PROJECT-SPECIFIC: Taxonomy mapping
# =============================================================================
taxonomy <- list(
  "Demosponges" = c(
    "Amphimedon_queenslandica", "Spongilla_lacustris", "Ephydatia_muelleri",
    "Tethya_wilhelma", "Halichondria_panicea", "Geodia_barretti"
  ),
  "Calcarea/Homoscl." = c(
    "Sycon_ciliatum", "Oscarella_lobularis", "Corticium_candelabrum"
  ),
  "Ctenophora" = c(
    "Mnemiopsis_leidyi", "Pleurobrachia_bachei", "Bolinopsis_microptera"
  ),
  "Cnidaria + Placozoa" = c(
    "Hydra_vulgaris", "Nematostella_vectensis", "Aurelia_aurita",
    "Clytia_hemisphaerica", "Sarsia_tubulosa", "Tripedalia_cystophora",
    "Cladocora_caespitosa", "Trichoplax_sp_H1", "Trichoplax_sp_H2",
    "Trichoplax_sp._H2", "Trichoplax_adhaerens", "Thelohanellus_kitauei",
    "Hydractinia_symbiolongicarpus"
  ),
  "Deuterostomia" = c(
    "Homo_sapiens", "Mus_musculus", "Danio_rerio", "Callorhinchus_milii",
    "Petromyzon_marinus", "Ambystoma_mexicanum", "Xenopus_tropicalis",
    "Ciona_intestinalis", "Strongylocentrotus_purpuratus",
    "Branchiostoma_lanceolatum", "Meara_stichopi", "Waminoa"
  ),
  "Protostomia" = c(
    "Drosophila_melanogaster", "Caenorhabditis_elegans",
    "Parasteatoda_tepidariorum", "Daphnia_pulex", "Hyalella_azteca",
    "Parhyale_hawaiensis", "Platynereis_dumerilii", "Schistosoma_mansoni",
    "Schmidtea_mediterranea", "Prostheceraeus_crozeri",
    "Biomphalaria_glabrata", "Crassostrea_gigas", "Aplysia_californica",
    "Acanthochitona_crinita", "Spadella_cephaloptera"
  )
)

uniprot_to_species <- c(
  HUMAN = "Homo_sapiens", MOUSE = "Mus_musculus",
  DROME = "Drosophila_melanogaster", CAEEL = "Caenorhabditis_elegans",
  DANRE = "Danio_rerio", ANOGA = "Anopheles_gambiae",
  RAT = "Rattus_norvegicus", BOVIN = "Bos_taurus",
  CHICK = "Gallus_gallus", XENLA = "Xenopus_laevis",
  SHEEP = "Ovis_aries", ARATH = "Arabidopsis_thaliana",
  DICDI = "Dictyostelium_discoideum"
)

# =============================================================================
# PROJECT-SPECIFIC: Model and focal species
# =============================================================================
model_species <- c("HUMAN", "MOUSE", "DROME", "CAEEL")
model_species_full <- c("Homo_sapiens", "Mus_musculus",
                        "Drosophila_melanogaster", "Caenorhabditis_elegans")

focal_species_full <- c(
  "Amphimedon_queenslandica", "Spongilla_lacustris", "Ephydatia_muelleri",
  "Tethya_wilhelma", "Halichondria_panicea", "Geodia_barretti",
  "Sycon_ciliatum", "Oscarella_lobularis", "Corticium_candelabrum",
  "Hydra_vulgaris", "Nematostella_vectensis"
)

# =============================================================================
# STYLE PARAMETERS
# =============================================================================
group_colors <- c(
  "Demosponges"         = "#2ca02c",
  "Calcarea/Homoscl."   = "#98df8a",
  "Ctenophora"          = "#9467bd",
  "Cnidaria + Placozoa" = "#ff7f0e",
  "Deuterostomia"       = "#d62728",
  "Protostomia"         = "#1f77b4",
  "Non-metazoan euk."   = "#555555",
  "Mixed"               = "#999999"
)

BRANCH_LINE_WIDTH  <- 0.15
TRIANGLE_ALPHA     <- 0.4
LABEL_SIZE_CIRC    <- 1.0
LABEL_OFFSET_CIRC  <- 0.005

# Page dimensions (square for circular layout)
PAGE_SIZE_OVERVIEW  <- 20     # inches — unlabeled overview
PAGE_SIZE_LABELED   <- 28     # inches — labeled version

# Collapsing parameters
COLLAPSE_MIN_PURITY   <- 0.90
COLLAPSE_MIN_SIZE     <- 3
COLLAPSE_MAX_FRACTION <- 0.25

abbrev_species <- function(sp_name) {
  parts <- strsplit(sp_name, "_")[[1]]
  if (length(parts) >= 2) return(paste0(substr(parts[1], 1, 1), ". ", parts[2]))
  return(sp_name)
}
```

## Build species lookup and assign tip data

```{r tip-data}
sp_to_group <- list()
for (group in names(taxonomy)) {
  for (sp in taxonomy[[group]]) sp_to_group[[sp]] <- group
}

get_group <- function(species_id) {
  if (species_id %in% names(sp_to_group)) return(sp_to_group[[species_id]])
  if (species_id %in% names(uniprot_to_species)) {
    mapped <- uniprot_to_species[species_id]
    if (mapped %in% names(sp_to_group)) return(sp_to_group[[mapped]])
  }
  return("Non-metazoan euk.")
}

resolve_species <- function(species_id) {
  if (species_id %in% names(uniprot_to_species)) return(uniprot_to_species[species_id])
  return(species_id)
}
```

## Prepare tree

```{r prepare-tree}
tree <- phytools::midpoint.root(tree)
cat("Midpoint rooted\n")

tip_species_id  <- sapply(tree$tip.label, parse_species_id)
tip_groups      <- sapply(tip_species_id, get_group)
tip_genes       <- mapply(resolve_gene_name, tree$tip.label, tip_species_id)
tip_species_full <- sapply(tip_species_id, resolve_species)

tip_data <- data.frame(
  label = tree$tip.label,
  species_id = tip_species_id,
  species_full = tip_species_full,
  group = tip_groups,
  gene = tip_genes,
  stringsAsFactors = FALSE,
  row.names = NULL
)

# Display label for selective labeling (model + focal species only)
all_focal_full <- c(model_species_full, focal_species_full)
tip_data$display_label <- NA_character_
for (i in seq_len(nrow(tip_data))) {
  sp_id  <- tip_data$species_id[i]
  sp_full <- tip_data$species_full[i]
  is_model <- sp_id %in% model_species | sp_full %in% model_species_full
  is_focal <- sp_full %in% focal_species_full
  if (is_model || is_focal) {
    sp_abbr <- abbrev_species(sp_full)
    gene <- tip_data$gene[i]
    if (!is.na(gene) && nchar(gene) > 0) {
      tip_data$display_label[i] <- paste0(sp_abbr, " ", gene)
    } else {
      tip_data$display_label[i] <- sp_abbr
    }
  }
}

cat("\nGroup counts:\n")
print(table(tip_data$group))
```

## Tree traversal helpers and node groups

```{r node-groups}
get_tips <- function(tree, node) {
  desc <- getDescendants(tree, node)
  desc[desc <= Ntip(tree)]
}

getDescendants <- function(tree, node) {
  n <- Ntip(tree)
  all_desc <- c()
  queue <- node
  while (length(queue) > 0) {
    current <- queue[1]
    queue <- queue[-1]
    children <- tree$edge[tree$edge[, 1] == current, 2]
    all_desc <- c(all_desc, children)
    queue <- c(queue, children[children > n])
  }
  return(all_desc)
}

n_tips <- Ntip(tree)
node_group <- rep(NA_character_, n_tips + Nnode(tree))

for (i in seq_len(nrow(tip_data))) {
  tip_idx <- match(tip_data$label[i], tree$tip.label)
  if (!is.na(tip_idx)) node_group[tip_idx] <- tip_data$group[i]
}

for (nd in (n_tips + 1):(n_tips + Nnode(tree))) {
  nd_tips <- get_tips(tree, nd)
  nd_groups <- node_group[nd_tips]
  nd_groups <- nd_groups[!is.na(nd_groups)]
  if (length(nd_groups) > 0) {
    grp_tab <- sort(table(nd_groups), decreasing = TRUE)
    if (grp_tab[1] / sum(grp_tab) > 0.5) {
      node_group[nd] <- names(grp_tab)[1]
    } else {
      node_group[nd] <- "Mixed"
    }
  }
}
```

## Collapse pure taxonomic group clades

```{r collapse}
find_collapsible_by_group <- function(tree, tip_data,
                                       min_purity = COLLAPSE_MIN_PURITY,
                                       min_size = COLLAPSE_MIN_SIZE,
                                       max_fraction = COLLAPSE_MAX_FRACTION,
                                       collapse_groups = NULL) {
  n_tips <- Ntip(tree)
  max_size <- floor(n_tips * max_fraction)
  node_ids <- (n_tips + 1):(n_tips + Nnode(tree))

  clade_info <- lapply(node_ids, function(nd) {
    nd_tips <- get_tips(tree, nd)
    nd_groups <- tip_data$group[nd_tips]
    grp_tab <- sort(table(nd_groups), decreasing = TRUE)
    list(node = nd, size = length(nd_tips),
         dominant_group = names(grp_tab)[1],
         purity = grp_tab[1] / length(nd_tips),
         tip_ids = nd_tips,
         group = names(grp_tab)[1])
  })

  candidates <- Filter(function(x) {
    group_ok <- if (is.null(collapse_groups)) TRUE else
                x$dominant_group %in% collapse_groups
    x$purity >= min_purity & x$size >= min_size & x$size <= max_size & group_ok
  }, clade_info)

  candidates <- candidates[order(sapply(candidates, `[[`, "size"),
                                  decreasing = TRUE)]

  selected <- list()
  collapsed_tips <- integer(0)
  for (cand in candidates) {
    if (any(cand$tip_ids %in% collapsed_tips)) next
    selected <- c(selected, list(cand))
    collapsed_tips <- c(collapsed_tips, cand$tip_ids)
  }
  return(selected)
}

# PROJECT-SPECIFIC: Which groups to collapse (NULL = all groups eligible)
clades_to_collapse <- find_collapsible_by_group(tree, tip_data,
                                                 collapse_groups = c("Bilateria"))

cat("Collapsing", length(clades_to_collapse), "clades:\n")
for (cl in clades_to_collapse) {
  cat(sprintf("  Node %d: %d tips (%s, %.0f%% pure)\n",
              cl$node, cl$size, cl$dominant_group, cl$purity * 100))
}

collapsed_tip_ids <- unlist(lapply(clades_to_collapse, function(cl) cl$tip_ids))
visible_tip_ids <- setdiff(seq_len(Ntip(tree)), collapsed_tip_ids)
```

## Build collapse labels with model species gene names

```{r collapse-labels}
# Filter out UniProt accession-like strings — keep only real gene symbols.
is_gene_symbol <- function(name) {
  if (is.na(name) || nchar(name) == 0) return(FALSE)
  if (grepl("^A0A", name)) return(FALSE)
  if (grepl("^[OPQ][0-9][A-Z0-9]{3}[0-9]$", name)) return(FALSE)
  if (grepl("^[A-NR-Z][0-9][A-Z][A-Z0-9]{2}[0-9]$", name)) return(FALSE)
  if (grepl("^[A-Z][0-9][A-Z0-9]{4,}", name)) return(FALSE)
  return(TRUE)
}

get_model_genes_in_clade <- function(cl, tip_data) {
  clade_tips <- tip_data[cl$tip_ids, ]
  model_rows <- clade_tips[
    clade_tips$species_id %in% model_species |
    clade_tips$species_full %in% model_species_full, ]
  if (nrow(model_rows) == 0) return(NULL)
  genes <- model_rows$gene[!is.na(model_rows$gene) & nchar(model_rows$gene) > 0]
  genes <- genes[sapply(genes, is_gene_symbol)]
  if (length(genes) == 0) return(NULL)
  return(unique(sort(genes)))
}

format_collapse_label <- function(cl, tip_data) {
  genes <- get_model_genes_in_clade(cl, tip_data)
  if (is.null(genes)) {
    paste0(cl$dominant_group, " (", cl$size, " tips)")
  } else {
    gene_str <- paste(genes, collapse = ", ")
    paste0(cl$dominant_group, " (", cl$size, " tips: ", gene_str, ")")
  }
}

for (cl in clades_to_collapse) {
  cat(format_collapse_label(cl, tip_data), "\n")
}
```

## Render circular overview (no labels)

```{r circular-overview}
#| fig-width: 20
#| fig-height: 20

p <- ggtree(tree, layout = "circular",
            size = BRANCH_LINE_WIDTH, aes(color = group)) %<+% tip_data

p$data$group <- node_group[p$data$node]
p$data$group[is.na(p$data$group)] <- "Mixed"

# Pre-compute positions BEFORE collapse
pre_data <- p$data

# Apply collapse
for (cl in clades_to_collapse) {
  color <- group_colors[cl$group]
  if (is.na(color)) color <- "#555555"
  p <- p |> collapse(node = cl$node, mode = "max",
                     fill = color, alpha = TRIANGLE_ALPHA, color = color,
                     linewidth = BRANCH_LINE_WIDTH)
}

p <- p +
  scale_color_manual(values = group_colors, na.value = "#999999",
                     name = "Taxonomic Group") +
  theme_tree() +
  theme(
    plot.margin = margin(5, 5, 5, 5),
    legend.position = "bottom",
    legend.text = element_text(size = 8),
    legend.title = element_text(size = 9, face = "bold")
  ) +
  guides(color = guide_legend(override.aes = list(linewidth = 2)))

ggsave(file.path(out_dir, "GENE_ggtree_circular.pdf"), p,
       width = PAGE_SIZE_OVERVIEW, height = PAGE_SIZE_OVERVIEW, units = "in")

p
```

## Render circular with selective labels

```{r circular-labeled}
#| fig-width: 28
#| fig-height: 28

p2 <- ggtree(tree, layout = "circular",
             size = BRANCH_LINE_WIDTH, aes(color = group)) %<+% tip_data

p2$data$group <- node_group[p2$data$node]
p2$data$group[is.na(p2$data$group)] <- "Mixed"

# --- CRITICAL: Pre-compute label positions BEFORE collapse ---
pre_data2 <- p2$data

# Tip labels (selective: model + focal species only)
visible_rows <- tip_data[!is.na(tip_data$display_label), ]
tip_label_df <- NULL
if (nrow(visible_rows) > 0) {
  tip_node_ids <- match(visible_rows$label, tree$tip.label)
  data_row_idx <- match(tip_node_ids, pre_data2$node)

  # Compute angle from y-position for circular layout
  max_y <- max(pre_data2$y, na.rm = TRUE)
  angles <- pre_data2$y[data_row_idx] / max_y * 360

  # Flip text on the left half of circle for readability
  flip <- angles > 90 & angles < 270
  display_angles <- ifelse(flip, angles + 180, angles)
  hjust_vals <- ifelse(flip, 1, 0)
  offset_sign <- ifelse(flip, -1, 1)

  tip_label_df <- data.frame(
    x = pre_data2$x[data_row_idx] + LABEL_OFFSET_CIRC * offset_sign,
    y = pre_data2$y[data_row_idx],
    tip_label = visible_rows$display_label,
    group = visible_rows$group,
    angle = display_angles,
    hjust = hjust_vals,
    stringsAsFactors = FALSE
  )
}

# Collapse triangle labels — position at max(x) of descendant tips
collapse_label_df2 <- NULL
if (length(clades_to_collapse) > 0) {
  collapse_label_df2 <- do.call(rbind, lapply(clades_to_collapse, function(cl) {
    nd_row <- match(cl$node, pre_data2$node)
    tip_x_max <- max(pre_data2$x[cl$tip_ids])
    tip_y <- pre_data2$y[nd_row]
    lbl <- format_collapse_label(cl, tip_data)

    # Compute angle for circular positioning
    max_y <- max(pre_data2$y, na.rm = TRUE)
    angle <- tip_y / max_y * 360
    flip <- angle > 90 & angle < 270
    display_angle <- ifelse(flip, angle + 180, angle)
    hjust_val <- ifelse(flip, 1, 0)
    offset_sign <- ifelse(flip, -1, 1)

    data.frame(x = tip_x_max + LABEL_OFFSET_CIRC * offset_sign,
               y = tip_y, tip_label = lbl,
               group = cl$group, angle = display_angle, hjust = hjust_val,
               stringsAsFactors = FALSE)
  }))
}

# Apply collapse
for (cl in clades_to_collapse) {
  color <- group_colors[cl$group]
  if (is.na(color)) color <- "#555555"
  p2 <- p2 |> collapse(node = cl$node, mode = "max",
                        fill = color, alpha = TRIANGLE_ALPHA, color = color,
                        linewidth = BRANCH_LINE_WIDTH)
}

# Add labels with pre-computed positions and angles
if (!is.null(tip_label_df) && nrow(tip_label_df) > 0) {
  p2 <- p2 +
    geom_text(data = tip_label_df,
              aes(x = x, y = y, label = tip_label, color = group),
              angle = tip_label_df$angle,
              hjust = tip_label_df$hjust,
              size = LABEL_SIZE_CIRC,
              show.legend = FALSE, inherit.aes = FALSE)
}

if (!is.null(collapse_label_df2) && nrow(collapse_label_df2) > 0) {
  p2 <- p2 +
    geom_text(data = collapse_label_df2,
              aes(x = x, y = y, label = tip_label, color = group),
              angle = collapse_label_df2$angle,
              hjust = collapse_label_df2$hjust,
              size = LABEL_SIZE_CIRC * 0.85, fontface = "italic",
              show.legend = FALSE, inherit.aes = FALSE)
}

p2 <- p2 +
  scale_color_manual(values = group_colors, na.value = "#999999",
                     name = "Taxonomic Group") +
  theme_tree() +
  theme(
    plot.margin = margin(5, 5, 5, 5),
    legend.position = "bottom",
    legend.text = element_text(size = 8),
    legend.title = element_text(size = 9, face = "bold")
  ) +
  guides(color = guide_legend(override.aes = list(linewidth = 2)))

ggsave(file.path(out_dir, "GENE_ggtree_circular_labeled.pdf"), p2,
       width = PAGE_SIZE_LABELED, height = PAGE_SIZE_LABELED, units = "in")

p2
```

## Session info

```{r build-info}
writeLines(
  c(
    paste("script: XX_tree_name.qmd"),
    paste("commit:", git_hash),
    paste("date:", format(Sys.time(), "%Y-%m-%d %H:%M:%S"))
  ),
  file.path(out_dir, "BUILD_INFO.txt")
)

sessionInfo()
```
